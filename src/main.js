import * as core from '@actions/core'
import * as github from '@actions/github'
import * as exec from '@actions/exec'
import { wait } from './wait.js'
import { getChangedFiles } from './git-diff.js'
import { reviewChangesWithAI, isAIReviewEnabled } from './ai-reviewer.js'
import { getActionConfig } from './config.js'
import { postReviewComment, isPullRequestContext } from './pr-comment.js'
import {
  generateTestsForChanges,
  isTestGenerationEnabled
} from './test-generator.js'

/**
 * Check if the current event is a comment trigger for test generation
 * @returns {boolean} True if this is a test generation comment trigger
 */
function isTestGenerationCommentTrigger() {
  const eventName = github.context.eventName
  const payload = github.context.payload

  if (eventName !== 'issue_comment') {
    return false
  }

  // Check if comment is on a pull request
  if (!payload.issue?.pull_request) {
    return false
  }

  // Check if comment contains test generation trigger
  const comment = payload.comment?.body?.toLowerCase() || ''
  const triggerPhrases = [
    'write tests',
    'generate tests',
    '/test',
    'create tests'
  ]

  return triggerPhrases.some((phrase) => comment.includes(phrase))
}

/**
 * Handle comment-triggered test generation
 * @returns {Promise<void>}
 */
async function handleTestGenerationComment() {
  try {
    const payload = github.context.payload
    const token = core.getInput('github-token')
    const octokit = github.getOctokit(token)

    // Get PR information
    const prNumber = payload.issue.number
    const { owner, repo } = github.context.repo

    core.info(`üß™ Test generation requested for PR #${prNumber}`)

    // Get PR details to access the head SHA
    const { data: pr } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: prNumber
    })

    // Checkout the PR head
    try {
      await exec.exec('git', [
        'fetch',
        'origin',
        `pull/${prNumber}/head:pr-${prNumber}`
      ])
      await exec.exec('git', ['checkout', `pr-${prNumber}`])
    } catch (error) {
      core.warning(
        `Failed to checkout PR branch: ${error.message}. Using current branch.`
      )
    }

    // Get changed files for this PR
    const files = await getChangedFiles([])

    if (files.length === 0) {
      const noChangesComment = `ü§ñ **AI Test Generator**

No testable files found in this PR. The following file types are excluded from test generation:
- Test files (\`.test.\`, \`.spec.\`)
- Configuration files (\`.config.\`, \`.min.\`)
- Documentation (\`.md\`)
- Data files (\`.json\`, \`.yml\`, \`.yaml\`)
- Build artifacts and dependencies`

      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: noChangesComment
      })
      return
    }

    // Generate tests
    core.info('üî¨ Generating tests for changed files...')
    const testResults = await generateTestsForChanges(files)

    // Create comment with test results
    await postTestGenerationResults(
      octokit,
      owner,
      repo,
      prNumber,
      testResults,
      files
    )
  } catch (error) {
    core.setFailed(`Failed to handle test generation comment: ${error.message}`)
  }
}

/**
 * Post test generation results as a comment
 * @param {Object} octokit - GitHub API client
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {number} prNumber - Pull request number
 * @param {Array} testResults - Test generation results
 * @param {Array} files - Changed files
 */
async function postTestGenerationResults(
  octokit,
  owner,
  repo,
  prNumber,
  testResults,
  files
) {
  const successfulTests = testResults.filter((r) => r.success && r.testContent)
  const failedTests = testResults.filter((r) => !r.success)

  let comment = `ü§ñ **AI Test Generator Results**\n\n`

  if (successfulTests.length > 0) {
    comment += `‚úÖ **Successfully generated ${successfulTests.length} test file(s):**\n\n`

    for (const result of successfulTests) {
      comment += `### üìÅ \`${result.testConfig.path}\`\n\n`
      comment += `<details>\n<summary>View generated test code</summary>\n\n`
      comment += `\`\`\`${result.testConfig.framework === 'pytest' ? 'python' : 'javascript'}\n`
      comment += result.testContent
      comment += `\n\`\`\`\n\n</details>\n\n`
    }
  }

  if (failedTests.length > 0) {
    comment += `‚ùå **Failed to generate tests for ${failedTests.length} file(s):**\n\n`
    for (const result of failedTests) {
      comment += `- \`${result.fileName}\`: ${result.error || 'Unknown error'}\n`
    }
    comment += `\n`
  }

  if (successfulTests.length === 0 && failedTests.length === 0) {
    comment += `‚ÑπÔ∏è No testable files found in the changes.\n\n`
  }

  comment += `---\n*Generated by AI Test Generator. Copy the test code above and save it to the suggested file paths.*`

  await octokit.rest.issues.createComment({
    owner,
    repo,
    issue_number: prNumber,
    body: comment
  })

  core.info(`‚úÖ Posted test generation results as comment`)
}

/**
 * Print diff summary and trigger AI review
 * @returns {Promise<void>}
 */
async function processBranchChanges() {
  try {
    // Get custom exclusion patterns from input
    const excludedFilesInput = core.getInput('excluded-files')
    const customExclusions = excludedFilesInput
      ? excludedFilesInput
          .split(',')
          .map((pattern) => pattern.trim())
          .filter(Boolean)
      : []

    if (customExclusions.length > 0) {
      core.info(`üìã Custom exclusion patterns: ${customExclusions.join(', ')}`)
    }

    const files = await getChangedFiles(customExclusions)

    if (files.length === 0) {
      core.info('No changes detected between this branch and main.')
      return
    }

    core.info(`üìä Found ${files.length} changed file(s):`)
    files.forEach((file) => {
      core.info(`  - ${file.fileName}`)
    })

    // Perform AI review if enabled
    if (isAIReviewEnabled()) {
      const reviewResults = await reviewChangesWithAI(files)

      // Post review comment to PR if in PR context
      if (isPullRequestContext()) {
        await postReviewComment(reviewResults)
      } else {
        core.info('üí¨ Not in PR context - review posted to logs only')
      }
    } else {
      core.info('üí° Add OpenAI API key to enable AI code review.')
    }

    // Generate unit tests if enabled
    if (isTestGenerationEnabled()) {
      await generateTestsForChanges(files)
    } else {
      core.info(
        'üß™ Test generation is disabled. Set generate-tests: true to enable.'
      )
    }
  } catch (error) {
    core.setFailed(`Failed to process branch changes: ${error.message}`)
  }
}

/**
 * The main function for the action.
 *
 * @returns {Promise<void>} Resolves when the action is complete.
 */
export async function run() {
  try {
    const config = getActionConfig()

    core.info('üöÄ Starting AI Code Review Action...')

    // Debug logs are only output if the `ACTIONS_STEP_DEBUG` secret is true
    core.debug(`Waiting ${config.waitTime} milliseconds ...`)

    // Log the current timestamp, wait, then log the new timestamp
    core.debug(new Date().toTimeString())
    await wait(config.waitTime)
    core.debug(new Date().toTimeString())

    // Set outputs for other workflow steps to use
    core.setOutput('time', new Date().toTimeString())

    // Check if this is a comment-triggered test generation
    if (isTestGenerationCommentTrigger()) {
      core.info('üß™ Comment-triggered test generation detected!')
      await handleTestGenerationComment()
    } else {
      // Process branch changes and perform AI review
      await processBranchChanges()
    }

    core.info('‚úÖ Action completed successfully!')
  } catch (error) {
    // Fail the workflow run if an error occurs
    if (error instanceof Error) core.setFailed(error.message)
  }
}
